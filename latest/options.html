<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Options · MINLPBnB</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MINLPBnB</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li class="current"><a class="toctext" href="options.html">Options</a><ul class="internal"><li><a class="toctext" href="#General-1">General</a></li><li><a class="toctext" href="#Branching-1">Branching</a></li><li><a class="toctext" href="#Objective-Cuts-1">Objective Cuts</a></li><li><a class="toctext" href="#Options-for-strong-branching-1">Options for strong branching</a></li><li><a class="toctext" href="#Parallel-1">Parallel</a></li><li><a class="toctext" href="#User-Limits-1">User Limits</a></li><li><a class="toctext" href="#Logging-1">Logging</a></li></ul></li><li><a class="toctext" href="extras.html">Extras</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="options.html">Options</a></li></ul><a class="edit-page" href="https://github.com/Wikunia/MINLPBnB/blob/master/docs/src/options.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Options</span><a class="fa fa-bars" href="#"></a></div></header><h2><a class="nav-anchor" id="General-1" href="#General-1">General</a></h2><pre><code class="language-none">MINLPBnBSolver(IpoptSolver(print_level=0))</code></pre><p>This is the most basic configuration of the solver.</p><p>The first argument defines the solver for the relaxation here <code>IpoptSolver</code>. I use <a href="https://projects.coin-or.org/Ipopt">Ipopt</a> for all the tests as well. The Ipopt julia package is described <a href="https://github.com/JuliaOpt/Ipopt.jl">here</a> The solver itself can have parameters i.e <code>print_level=0</code>.</p><p>A list of some NLP solvers is mentioned <a href="http://www.juliaopt.org/JuMP.jl/0.18/installation.html#getting-solvers">here</a></p><p>You can add options doing the following:</p><pre><code class="language-none">minlpbnb = MINLPBnBSolver(IpoptSolver(print_level=0);
    branch_strategy=:StrongPseudoCost
)</code></pre><p>In this example the strategy used for branching is defined.</p><p>In the following the options are explained. The type for the option is given after <code>::</code> and the default value in <code>[]</code>.</p><p><strong>Attention:</strong> The default values might change in the future after several tests were executed to determine the best overall options. </p><h2><a class="nav-anchor" id="Branching-1" href="#Branching-1">Branching</a></h2><h3><a class="nav-anchor" id="branch_strategy::Symbol-[:StrongPseudoCost]-1" href="#branch_strategy::Symbol-[:StrongPseudoCost]-1">branch_strategy::Symbol [:StrongPseudoCost]</a></h3><p>Possible values:</p><ul><li><p><code>:MostInfeasible</code></p><ul><li><p>Branch on variables closest to 0.5</p></li></ul></li><li><p><code>:PseudoCost</code></p><ul><li><p>Use <code>:MostInfeasible</code> first and then <a href="https://en.wikipedia.org/wiki/Branch_and_cut#Branching_Strategies">Pseudo Cost Branching</a>.</p></li></ul></li><li><p><code>:StrongPseudoCost</code></p><ul><li><p>Use <a href="https://en.wikipedia.org/wiki/Branch_and_cut#Branching_Strategies">Strong Branching</a> first and then <code>:PseudoCost</code>.</p></li></ul></li></ul><h3><a class="nav-anchor" id="traverse_strategy::Symbol-[:BFS]-1" href="#traverse_strategy::Symbol-[:BFS]-1">traverse_strategy::Symbol [:BFS]</a></h3><p>Determines which node is used for the next branching.</p><p>Possible values:</p><ul><li><p><code>:BFS</code></p><ul><li><p>Best-first-search: always take the node with the best bound</p></li></ul></li><li><p><code>:DFS</code></p><ul><li><p>Depth-first-search: always take the node with the highest level</p></li><li><p>Might find a feasible solution faster</p></li></ul></li><li><p><code>:DBFS</code></p><ul><li><p>Use of DFS first until the first feasible solution is found then switch to BFS</p></li></ul></li></ul><h2><a class="nav-anchor" id="Objective-Cuts-1" href="#Objective-Cuts-1">Objective Cuts</a></h2><h3><a class="nav-anchor" id="incumbent_constr::Bool-[true]-1" href="#incumbent_constr::Bool-[true]-1">incumbent_constr::Bool [true]</a></h3><p>Add a constraint <code>objval &gt;=/&lt;= incumbent</code>. </p><h3><a class="nav-anchor" id="obj_epsilon::0-[Float64]-1" href="#obj_epsilon::0-[Float64]-1">obj_epsilon::0 [Float64]</a></h3><p>Add a constraint of the following form at the root node if not <code>0</code>.</p><p>If minimizing:</p><div>\[\text{obj } \leq (1+\epsilon)\text{LB}\]</div><p>If maximizing:</p><div>\[\text{obj } \geq (1-\epsilon)\text{UB}\]</div><h2><a class="nav-anchor" id="Options-for-strong-branching-1" href="#Options-for-strong-branching-1">Options for strong branching</a></h2><h3><a class="nav-anchor" id="strong_branching_nvars::Int64-[5]-1" href="#strong_branching_nvars::Int64-[5]-1">strong_branching_nvars::Int64 [5]</a></h3><p>Defines the number of variables to consider for strong branching. </p><h3><a class="nav-anchor" id="strong_branching_nsteps::Int64-[1]-1" href="#strong_branching_nsteps::Int64-[1]-1">strong_branching_nsteps::Int64 [1]</a></h3><p>Defines the number of steps in which strong branching is used. <code>:PseudoCost</code> will be used for later steps.</p><h3><a class="nav-anchor" id="strong_restart::Bool-[true]-1" href="#strong_restart::Bool-[true]-1">strong_restart::Bool [true]</a></h3><p>If a child while running strong branching is infeasible this holds for the whole node. Therefore we can tighten the bounds and rerun the strong branch part. (This might occur more then once)</p><h2><a class="nav-anchor" id="Parallel-1" href="#Parallel-1">Parallel</a></h2><p>MINLPBnB can be run in parallel to speed up the algorithm. You have to start julia with <code>julia -p P</code> where <code>P</code> is the number of processors available or at least the number of processors you want to use.</p><p>Then you have to specify the number of processor as an option.</p><h3><a class="nav-anchor" id="processors::Int64-[1]-1" href="#processors::Int64-[1]-1">processors::Int64 [1]</a></h3><p>The number of processors used for the branch and bound part. <strong>Attention:</strong> Even if you start julia using <code>julia -p P</code> you still have to define the number of processors using this option.</p><h2><a class="nav-anchor" id="User-Limits-1" href="#User-Limits-1">User Limits</a></h2><p>You can stop the solver before the optimal solution is found. This is reasonable if the problem is to big to solve to optimality fast. If the solver stops because of one of the following options the status <code>:UserLimit</code> is returned.</p><h3><a class="nav-anchor" id="time_limit::Float64-[Inf]-1" href="#time_limit::Float64-[Inf]-1">time_limit::Float64 [Inf]</a></h3><p>The maximum time in seconds the solver should run. </p><p><strong>Note:</strong> The solver will check after each branching step therefore it isn&#39;t a strict limit and depends on the duration of a relaxation.</p><h3><a class="nav-anchor" id="mip_gap::Float64-[0.01]%-1" href="#mip_gap::Float64-[0.01]%-1">mip_gap::Float64 [0.01]%</a></h3><p>Stops the solver if the gap is smaller than <code>mip_gap</code>. This is a percentage value.</p><h3><a class="nav-anchor" id="best_obj_stop::Float-[NaN]-1" href="#best_obj_stop::Float-[NaN]-1">best_obj_stop::Float [NaN]</a></h3><p>If an incumbent is found which is better than <code>best_obj_stop</code> the incumbent is returned. A warning gets thrown if <code>best_obj_stop</code> can&#39;t be reached.</p><h3><a class="nav-anchor" id="solution_limit::Int-[0]-1" href="#solution_limit::Int-[0]-1">solution_limit::Int [0]</a></h3><p>The solver stops if the requested amount of feasible solutions is found. If <code>0</code> the option gets ignored.</p><h2><a class="nav-anchor" id="Logging-1" href="#Logging-1">Logging</a></h2><h3><a class="nav-anchor" id="log_levels::Vector{Symbol}-[[:Table,:Info]]-1" href="#log_levels::Vector{Symbol}-[[:Table,:Info]]-1">log_levels::Vector{Symbol} [[:Table,:Info]]</a></h3><p>You can change the option <code>log_levels</code> to define what kind of logs you want to see.</p><p>The default is <code>[:Table,:Info]</code> which outputs something like this:</p><p><img src="https://user-images.githubusercontent.com/4931746/32625934-07b7db3c-c58e-11e7-922d-18a0a8776437.png" alt="default-logging"/></p><p>Possible symbols which can be added to the vector are:</p><ul><li><p>:Timing</p><ul><li><p>Provides some more timing informations</p></li></ul></li><li><p>:Options</p><ul><li><p>prints all options that differ from default</p></li></ul></li><li><p>:AllOptions</p><ul><li><p>prints all options </p></li></ul></li></ul><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="extras.html"><span class="direction">Next</span><span class="title">Extras</span></a></footer></article></body></html>
